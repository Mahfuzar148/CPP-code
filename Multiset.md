
---

# ЁЯза C++ `std::multiset` тАФ ржПржХржжржо ржкрж░рж┐рж╖рзНржХрж╛рж░ ржзрж╛рж░ржгрж╛

---

## ЁЯФ╖ `multiset` ржХрзА?

`std::multiset` рж╣рж▓ C++ STL-ржПрж░ ржПржХржЯрж┐ **associative container** ржпрж╛:

* ржЙржкрж╛ржжрж╛ржиржЧрзБрж▓рзЛ **sorted рж░рж╛ржЦрзЗ** (default: ascending)
* ржПржХржЗ ржЙржкрж╛ржжрж╛ржи **multiple ржмрж╛рж░ рж░рж╛ржЦрждрзЗ ржкрж╛рж░рзЗ**
* ржнрж┐рждрж░рзЗ **Red-Black Tree (Self-Balancing BST)** ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ
* Operations: `O(log n)` ржЯрж╛ржЗржорзЗ insert, delete, search ржЗрждрзНржпрж╛ржжрж┐ ржХрж░рзЗ

---

## тЬЕ ржорзВрж▓ ржХрж╛ржЬ ржУ ржмрзНржпржмрж╣рж╛рж░

| ржХрж╛ржЬ / ржмрзНржпржмрж╣рж╛рж░                        | ржЙржжрж╛рж╣рж░ржг / ржмрзНржпрж╛ржЦрзНржпрж╛                             |
| ------------------------------------ | --------------------------------------------- |
| ЁЯФБ Sorted data рж░рж╛ржЦрж╛                  | `{3,1,2,1}` тЖТ `1 1 2 3`                       |
| ЁЯФВ ржПржХржЗ ржЙржкрж╛ржжрж╛ржи ржмрж╛рж░ржмрж╛рж░ рж░рж╛ржЦрж╛            | `{"Ali", "Bob", "Ali"}` тЖТ `Ali Ali Bob`       |
| ЁЯФН Value-based search, count         | `s.count(10)` тЖТ 10 ржПрж░ ржХрзЯржЯрж╛ instance           |
| ЁЯУК Frequency tracking in sorted way  | ржорж╛рж░рзНржХрзЗржЯрзЗ ржжрж╛ржо tracking, ржлрж▓рж╛ржлрж▓ рж╣рж┐рж╕рж╛ржм            |
| ЁЯПЖ Leaderboard / Bidding system      | ржПржХржЗ score рж╕рж╣ ржЕржирзЗржХ entry, ржЕржержЪ sorted рж░рж╛ржЦрждрзЗ рж╣ржмрзЗ |
| ЁЯОп Efficient sliding window problems | Competitive programming-ржПрж░ ржЯрж┐ржкрж┐ржХрзНржпрж╛рж▓ use-case |

---

## ЁЯЫая╕П ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг Operations ржУ Time Complexity

| Operation          | Time Complexity | ржмрзНржпрж╛ржЦрзНржпрж╛                          |
| ------------------ | --------------- | --------------------------------- |
| `insert(val)`      | `O(log n)`      | Tree-рждрзЗ ржбрзЗржЯрж╛ ржврзЛржХрж╛рзЯ                |
| `erase(val)`       | `O(log n)`      | ржбрзБржкрзНрж▓рж┐ржХрзЗржЯрж╕рж╣ рж╕ржм instance ржорзБржЫрзЗ ржлрзЗрж▓рзЗ |
| `find(val)`        | `O(log n)`      | ржЙржкрж╛ржжрж╛ржи ржЦрзБржБржЬрзЗ iterator ржжрзЗрзЯ         |
| `count(val)`       | `O(log n)`      | ржХрзЯржмрж╛рж░ ржЖржЫрзЗ рждрж╛ ржЧрзБржирзЗ ржжрзЗрзЯ             |
| `lower_bound(val)` | `O(log n)`      | ржкрзНрж░ржержо `>= val` element            |
| `upper_bound(val)` | `O(log n)`      | ржкрзНрж░ржержо `> val` element             |
| `equal_range(val)` | `O(log n)`      | lower ржПржмржВ upper bound ржПрж░ pair     |
| `begin()/end()`    | `O(1)`          | ржкрзНрж░ржержо ржУ рж╢рзЗрж╖ iterator              |
| `size()/empty()`   | `O(1)`          | ржорзЛржЯ ржЙржкрж╛ржжрж╛ржи рж╕ржВржЦрзНржпрж╛ / ржЦрж╛рж▓рж┐ ржХрж┐ржирж╛     |

---

## ЁЯФА ржХржЦржи `multiset` Efficient?

| Use-case                        | ржХрзЗржи `multiset` ржЙржкржпрзБржХрзНржд               |
| ------------------------------- | ------------------------------------ |
| Sorted duplicate tracking       | Automatically sorted with duplicates |
| Fast insertion + search + erase | рж╕ржм `O(log n)` ржЯрж╛ржЗржорзЗ рж╣рзЯ               |
| Frequency query with order      | `count(val)` & sorted access         |
| Range queries                   | `lower_bound`, `upper_bound`         |
| Competitive programming         | Sliding window, Top K elements etc.  |

---

## ЁЯЪл ржХржЦржи `multiset` Use ржХрж░рж╛ ржЙржЪрж┐ржд ржирзЯ?

| ржкрзНрж░ржпрж╝рзЛржЬржи / рж╕ржорж╕рзНржпрж╛                        | ржнрж╛рж▓рзЛ ржмрж┐ржХрж▓рзНржк             | ржХрж╛рж░ржг                          |
| ---------------------------------------- | ----------------------- | ----------------------------- |
| Unique element ржжрж░ржХрж╛рж░                     | `std::set`              | ржбрзБржкрзНрж▓рж┐ржХрзЗржЯ support ржХрж░рзЗ ржирж╛      |
| Fast hash-based access ржжрж░ржХрж╛рж░             | `unordered_multiset`    | average O(1), ржХрж┐ржирзНрждрзБ unsorted |
| Indexed access ржжрж░ржХрж╛рж░                     | `vector` / `deque`      | Random access `O(1)`          |
| Key-value frequency tracking (unordered) | `unordered_map<T, int>` | More explicit frequency store |

---

## ЁЯУж ржмрж╛рж╕рзНрждржм ржЙржжрж╛рж╣рж░ржг

### ЁЯз╛ ржЙржжрж╛рж╣рж░ржг рзз: ржорж╛рж░рзНржХрзЗржЯрзЗрж░ ржжрж╛ржо tracking

```cpp
std::multiset<int> prices = {100, 150, 100, 200};

prices.insert(100);
prices.erase(150);
```

тЮб Output: `100 100 100 200`

---

### ЁЯз╛ ржЙржжрж╛рж╣рж░ржг рзи: ржлрж▓рж╛ржлрж▓рзЗрж░ ржЧрзНрж░рзЗржбрж┐ржВ

```cpp
std::multiset<int> scores = {85, 90, 90, 78};

for (auto it = scores.rbegin(); it != scores.rend(); ++it)
    std::cout << *it << " ";
```

тЮб Output: `90 90 85 78` (Descending Order)

---

## ЁЯза рж╕ржВржХрзНрж╖рзЗржкрзЗ ржоржирзЗ рж░рж╛ржЦрж╛рж░ ржлрж░рзНржорзБрж▓рж╛

| Container            | ржбрзБржкрзНрж▓рж┐ржХрзЗржЯ | Sorted | ржЯрж╛ржЗржо ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐ | ржмрзНржпржмрж╣рж╛рж░                        |
| -------------------- | --------- | ------ | ----------------- | ------------------------------ |
| `set`                | тЭМ         | тЬЕ      | `O(log n)`        | Unique, ordered data           |
| `multiset`           | тЬЕ         | тЬЕ      | `O(log n)`        | Duplicate + ordered            |
| `unordered_set`      | тЭМ         | тЭМ      | `avg O(1)`        | Unique, fast access, unordered |
| `unordered_multiset` | тЬЕ         | тЭМ      | `avg O(1)`        | Duplicate + fast, unordered    |
| `map`, `multimap`    | Key-value | тЬЕ      | `O(log n)`        | Key-value store with ordering  |
| `unordered_map`      | Key-value | тЭМ      | `avg O(1)`        | Key-value, fast, unordered     |

---

## тЬЕ ржЙржкрж╕ржВрж╣рж╛рж░

ЁЯФ╣ ржпржжрж┐ **sorted** ржПржмржВ **duplicate-friendly** container ржжрж░ржХрж╛рж░ рж╣рзЯ тАФ рждрж╛рж╣рж▓рзЗ `multiset` рж╕рзЗрж░рж╛ рж╕ржорж╛ржзрж╛ржиред

ЁЯФ╣ ржпрзЗржЦрж╛ржирзЗ `insert`, `search`, `delete` тАФ рж╕ржм efficiently ржХрж░рждрзЗ рж╣ржмрзЗ ржПржмржВ ржбрзЗржЯрж╛ ржЕрж░рзНржбрж╛рж░ ржорзЗржЗржиржЯрзЗржЗржи ржХрж░рждрзЗ рж╣ржмрзЗ, рж╕рзЗржЦрж╛ржирзЗржЗ `multiset` shine ржХрж░рзЗред

ЁЯФ╣ Competitive programming, frequency tracking, logics with sorted duplicates тАФ ржПрж╕ржм ржХрзНрж╖рзЗрждрзНрж░рзЗ highly efficientред

---




---

### ЁЯУЪ `std::multiset` ржПрж░ рж╕ржХрж▓ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржлрж╛ржВрж╢ржирзЗрж░ рж▓рж┐рж╕рзНржЯ

`std::multiset` рж╣рж▓ ржПржХржЯрж┐ STL container ржпрзЗржЯрж┐ **sorted** order ржП ржПрж▓рж┐ржорзЗржирзНржЯ рж░рж╛ржЦрзЗ ржПржмржВ **duplicate** ржПрж▓рж┐ржорзЗржирзНржЯ рж░рж╛ржЦрждрзЗ ржкрж╛рж░рзЗред

#### тЬЕ Constructor Functions

* `multiset<T> s;` тАФ ржЦрж╛рж▓рж┐ multiset рждрзИрж░рж┐ред
* `multiset<T> s(begin, end);` тАФ ржХрзЛржирзЛ рж░рзЗржЮрзНржЬ ржерзЗржХрзЗ ржбрзЗржЯрж╛ ржжрж┐рзЯрзЗ рждрзИрж░рж┐ред
* `multiset<T> s(const multiset<T>&);` тАФ ржХржкрж┐ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░ред
* `multiset<T> s(std::initializer_list<T>);` тАФ `{1,2,3}` ржПрж░ ржорждрзЛ ржЗржирзНрж╕рж╛рж░рзНржЯред

---

#### тЬЕ Insertion

* `s.insert(value);` тАФ ржПржХ ржмрж╛ ржПржХрж╛ржзрж┐ржХ ржХржкрж┐ ржЗржирж╕рж╛рж░рзНржЯред
* `s.insert(hint, value);` тАФ iterator hint рж╕рж╣ ржЗржирж╕рж╛рж░рзНржЯред
* `s.emplace(value);` тАФ ржЗржи-ржкрзНрж▓рзЗрж╕ ржХржирж╕рзНржЯрзНрж░рж╛ржХрж╢ржи ржХрж░рзЗ ржЗржирж╕рж╛рж░рзНржЯред

---

#### тЬЕ Deletion

* `s.erase(value);` тАФ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ value ржПрж░ рж╕ржм instance ржорзБржЫрзЗ ржлрзЗрж▓рзЗред
* `s.erase(pos);` тАФ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ iterator position ржерзЗржХрзЗ ржорзБржЫрзЗ ржлрзЗрж▓рзЗред
* `s.erase(start, end);` тАФ iterator рж░рзЗржЮрзНржЬ ржерзЗржХрзЗ ржорзБржЫрзЗ ржлрзЗрж▓рзЗред
* `s.clear();` тАФ рж╕ржм ржорзБржЫрзЗ ржлрзЗрж▓рзЗред

---

#### тЬЕ Search & Count

* `s.find(value);` тАФ iterator рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗ value ржкрзЗрж▓рзЗ, ржирж╛ ржкрзЗрж▓рзЗ `s.end()`ред
* `s.count(value);` тАФ ржХрзЯржЯрж╛ instance ржЖржЫрзЗ рж╕рзЗржЯрж╛ рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗред
* `s.equal_range(value);` тАФ pair\<iterator, iterator> ржжрзЗрзЯ, ржпрзЗржЦрж╛ржирзЗ value рж╢рзБрж░рзБ ржПржмржВ рж╢рзЗрж╖ рж╣рзЯред
* `s.lower_bound(value);` тАФ ржкрзНрж░ржержо iterator ржпрж╛ `>= value`ред
* `s.upper_bound(value);` тАФ ржкрзНрж░ржержо iterator ржпрж╛ `> value`ред

---

#### тЬЕ Capacity

* `s.empty();` тАФ ржЦрж╛рж▓рж┐ ржХрж┐ржирж╛ ржжрзЗржЦрзЗред
* `s.size();` тАФ ржорзЛржЯ ржХрждржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯ ржЖржЫрзЗред
* `s.max_size();` тАФ рж╕рж░рзНржмрзЛржЪрзНржЪ ржХрзЯржЯрж┐ рж░рж╛ржЦрждрзЗ ржкрж╛рж░рзЗред

---

#### тЬЕ Iterator Functions

* `s.begin(), s.end()` тАФ ржлрзНрж░ржирзНржЯ ржерзЗржХрзЗ ржЗржЯрж╛рж░рзЗрж╢ржиред
* `s.rbegin(), s.rend()` тАФ рж░рж┐ржнрж╛рж░рзНрж╕ ржЗржЯрж╛рж░рзЗрж╢ржиред
* `cbegin(), cend(), crbegin(), crend()` тАФ const ржЗржЯрж╛рж░рзЗрж╢ржиред

---

#### тЬЕ Others

* `s.swap(other);` тАФ ржжрзБржЗржЯрж╛ multiset ржПрж░ ржоржзрзНржпрзЗ data ржЕржжрж▓ржмржжрж▓ ржХрж░рзЗред
* `s.get_allocator();` тАФ ржорзЗржорзЛрж░рж┐ allocator рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗред

---



---

## тЬЕ Constructor Functions

---

### 1я╕ПтГг `multiset<T> s;` тАФ ржЦрж╛рж▓рж┐ multiset рждрзИрж░рж┐

### ЁЯзй Problem:

ржПржХржЯрж┐ ржЦрж╛рж▓рж┐ multiset рждрзИрж░рж┐ ржХрж░рзЛ ржПржмржВ рждрж╛рждрзЗ ржХрж┐ржЫрзБ рж╕ржВржЦрзНржпрж╛ insert ржХрж░рзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s; // empty multiset

    s.insert(3);
    s.insert(1);
    s.insert(2);

    for (int x : s)
        std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
1 2 3
```

---

### 2я╕ПтГг `multiset<T> s(begin, end);` тАФ рж░рзЗржЮрзНржЬ ржерзЗржХрзЗ рждрзИрж░рж┐

### ЁЯзй Problem:

ржПржХржЯрж┐ ржЕрзНржпрж╛рж░рзЗ ржерзЗржХрзЗ multiset рждрзИрж░рж┐ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    int arr[] = {5, 2, 3, 2, 5};

    std::multiset<int> s(arr, arr + 5); // range constructor

    for (int x : s)
        std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
2 2 3 5 5
```

---

### 3я╕ПтГг `multiset<T> s(const multiset<T>&);` тАФ ржХржкрж┐ ржХржирж╕рзНржЯрзНрж░рж╛ржХрзНржЯрж░

### ЁЯзй Problem:

ржПржХржЯрж┐ multiset ржХржкрж┐ ржХрж░рзЗ ржЖрж░рзЗржХржЯрж┐ рждрзИрж░рж┐ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> original = {1, 2, 2, 3};

    std::multiset<int> copy(original); // copy constructor

    for (int x : copy)
        std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
1 2 2 3
```

---

### 4я╕ПтГг `multiset<T> s(std::initializer_list<T>);`

### ЁЯзй Problem:

ржПржХржЯрж┐ initializer list ржжрж┐рзЯрзЗ multiset рждрзИрж░рж┐ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s{4, 1, 4, 3};

    for (int x : s)
        std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
1 3 4 4
```

---

## тЬЕ Insertion Functions

---

### 5я╕ПтГг `s.insert(value);` тАФ рж╕рж╛ржзрж╛рж░ржг ржЗржирж╕рж╛рж░рзНржЯ

(ржЗрждрж┐ржоржзрзНржпрзЗржЗ ржЙржкрж░рзЗрж░ ржЙржжрж╛рж╣рж░ржгрзЗ ржжрзЗржУрзЯрж╛ ржЖржЫрзЗ, ржЪрж▓ржЫрж┐ ржкрж░рзЗрж░ржЯрж╛рзЯ)

---

### 6я╕ПтГг `s.insert(hint, value);` тАФ hint рж╕рж╣ ржЗржирж╕рж╛рж░рзНржЯ

### ЁЯзй Problem:

ржПржХржЯрж┐ multiset-ржП insert ржХрж░рж╛рж░ рж╕ржорзЯ рж╣рж┐ржирзНржЯ (iterator) ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {10, 20, 30};

    auto it = s.begin(); // hint: beginning
    s.insert(it, 5);     // insert with hint (faster if correct)

    for (int x : s)
        std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
5 10 20 30
```

---

### 7я╕ПтГг `s.emplace(value);` тАФ ржЗржи-ржкрзНрж▓рзЗрж╕ ржЗржирж╕рж╛рж░рзНржЯ

### ЁЯзй Problem:

multiset-ржП `emplace` ржжрж┐рзЯрзЗ ржЗржи-ржкрзНрж▓рзЗрж╕ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s;

    s.emplace(8);
    s.emplace(3);
    s.emplace(8);

    for (int x : s)
        std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
3 8 8
```

---



---

## тЬЕ Deletion Functions

---

### 1я╕ПтГг `s.erase(value);` тАФ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ value ржПрж░ рж╕ржм instance ржорзБржЫрзЗ ржлрзЗрж▓рзЗ

### ЁЯзй Problem:

ржПржХржЯрж┐ multiset ржерзЗржХрзЗ ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ рж╕ржВржЦрзНржпрж╛ рж╕ржорзНржкрзВрж░рзНржгржнрж╛ржмрзЗ ржорзБржЫрзЗ ржлрзЗрж▓рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {1, 2, 2, 3, 4, 2};

    s.erase(2);  // remove all instances of 2

    for (int x : s)
        std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
1 3 4
```

---

### 2я╕ПтГг `s.erase(pos);` тАФ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ iterator ржерзЗржХрзЗ ржорзБржЫрзЗ ржлрзЗрж▓рзЗ

### ЁЯзй Problem:

multiset ржерзЗржХрзЗ ржкрзНрж░ржержо ржЙржкрж╛ржжрж╛ржиржЯрж┐ ржорзБржЫрзЗ ржлрзЗрж▓рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {10, 20, 30};

    auto it = s.begin(); // iterator to first element
    s.erase(it);         // remove first element

    for (int x : s)
        std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
20 30
```

---

### 3я╕ПтГг `s.erase(start, end);` тАФ ржПржХржЯрж┐ рж░рзЗржЮрзНржЬ ржорзБржЫрзЗ ржлрзЗрж▓рзЛ

### ЁЯзй Problem:

multiset ржерзЗржХрзЗ ржкрзНрж░ржержо ржжрзБржЗржЯрж┐ ржЙржкрж╛ржжрж╛ржи ржорзБржЫрзЗ ржлрзЗрж▓рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {5, 10, 15, 20};

    auto start = s.begin();
    auto end = std::next(start, 2); // second position

    s.erase(start, end); // remove first two elements

    for (int x : s)
        std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
15 20
```

---

### 4я╕ПтГг `s.clear();` тАФ рж╕ржм ржЙржкрж╛ржжрж╛ржи ржорзБржЫрзЗ ржлрзЗрж▓рзЛ

### ЁЯзй Problem:

multiset ржкрзБрж░рзЛржкрзБрж░рж┐ ржЦрж╛рж▓рж┐ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {1, 2, 3};

    s.clear();  // remove everything

    std::cout << "Size: " << s.size(); // should be 0
}
```

ЁЯУд **Output:**

```
Size: 0
```

---

## тЬЕ Search & Count Functions

---

### 5я╕ПтГг `s.find(value);` тАФ ржЙржкрж╛ржжрж╛ржи ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рзЛ

### ЁЯзй Problem:

multiset-ржП 30 ржЖржЫрзЗ ржХрж┐ржирж╛ ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {10, 20, 30, 40};

    auto it = s.find(30);
    if (it != s.end())
        std::cout << "Found: " << *it;
    else
        std::cout << "Not found";
}
```

ЁЯУд **Output:**

```
Found: 30
```

---

### 6я╕ПтГг `s.count(value);` тАФ ржХрзЯржмрж╛рж░ ржЖржЫрзЗ рж╕рзЗржЯрж╛ ржмрзЗрж░ ржХрж░рзЛ

### ЁЯзй Problem:

multiset-ржП 10 ржХрзЯржмрж╛рж░ ржЖржЫрзЗ рж╕рзЗржЯрж╛ ржжрзЗржЦрж╛ржУред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {10, 10, 20, 10};

    std::cout << "10 occurs " << s.count(10) << " times.";
}
```

ЁЯУд **Output:**

```
10 occurs 3 times.
```

---

### 7я╕ПтГг `s.equal_range(value);` тАФ ржПржХржЯрж╛ value-ржПрж░ рж╢рзБрж░рзБ ржУ рж╢рзЗрж╖ iterator pair

### ЁЯзй Problem:

multiset-ржП `10` ржПрж░ range iterator ржмрзЗрж░ ржХрж░рзЗ, ржР range ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {5, 10, 10, 10, 20};

    auto range = s.equal_range(10); // pair of iterators

    std::cout << "10s are: ";
    for (auto it = range.first; it != range.second; ++it)
        std::cout << *it << " ";
}
```

ЁЯУд **Output:**

```
10s are: 10 10 10
```

---

### 8я╕ПтГг `s.lower_bound(value);` тАФ ржкрзНрж░ржержо `>= value` ржПрж░ position

### ЁЯзй Problem:

multiset-ржП 15 ржмрж╛ рждрж╛рж░ ржЪрзЗрзЯрзЗ ржмрзЬ ржкрзНрж░ржержо рж╕ржВржЦрзНржпрж╛ ржжрзЗржЦрж╛ржУред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {5, 10, 15, 20};

    auto it = s.lower_bound(15);
    if (it != s.end())
        std::cout << "Lower bound: " << *it;
}
```

ЁЯУд **Output:**

```
Lower bound: 15
```

---

### 9я╕ПтГг `s.upper_bound(value);` тАФ ржкрзНрж░ржержо `> value` ржПрж░ position

### ЁЯзй Problem:

multiset-ржП 15 ржПрж░ ржЪрзЗрзЯрзЗ ржмрзЬ ржкрзНрж░ржержо рж╕ржВржЦрзНржпрж╛ ржжрзЗржЦрж╛ржУред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {5, 10, 15, 20};

    auto it = s.upper_bound(15);
    if (it != s.end())
        std::cout << "Upper bound: " << *it;
}
```

ЁЯУд **Output:**

```
Upper bound: 20
```

---
ржЪрж▓ ржПржмрж╛рж░ `std::multiset`-ржПрж░ тЬЕ **Capacity**, тЬЕ **Iterator Functions**, ржПржмржВ тЬЕ **Others** рж╕рзЗржХрж╢ржирзЗрж░ ржкрзНрж░рждрж┐ржЯрж┐ ржлрж╛ржВрж╢ржирзЗрж░ ржЬржирзНржп ржЫрзЛржЯ ржЫрзЛржЯ рж╕ржорж╕рзНржпрж╛ ржУ рждрж╛рж░ рж╕ржорж╛ржзрж╛ржи ржжрзЗржЦрж┐ред

---

## тЬЕ Capacity Functions

---

### 1я╕ПтГг `s.empty();` тАФ ржЦрж╛рж▓рж┐ ржХрж┐ржирж╛ ржпрж╛ржЪрж╛ржЗ ржХрж░рж╛

### ЁЯзй Problem:

multiset ржЦрж╛рж▓рж┐ ржХрж┐ржирж╛ рждрж╛ ржпрж╛ржЪрж╛ржЗ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s;

    if (s.empty())
        std::cout << "Set is empty\n";
    else
        std::cout << "Set has elements\n";

    s.insert(1);

    if (!s.empty())
        std::cout << "Now set has elements\n";
}
```

ЁЯУд **Output:**

```
Set is empty  
Now set has elements
```

---

### 2я╕ПтГг `s.size();` тАФ ржорзЛржЯ ржХрзЯржЯрж┐ ржЙржкрж╛ржжрж╛ржи ржЖржЫрзЗ

### ЁЯзй Problem:

multiset-ржП ржорзЛржЯ ржХрждржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯ ржЖржЫрзЗ рждрж╛ ржжрзЗржЦрж╛ржУред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {1, 2, 2, 3};

    std::cout << "Size: " << s.size();
}
```

ЁЯУд **Output:**

```
Size: 4
```

---

### 3я╕ПтГг `s.max_size();` тАФ рж╕рж░рзНржмрзЛржЪрзНржЪ ржХрждржЯрж┐ рж░рж╛ржЦрждрзЗ ржкрж╛рж░ржмрзЗ (рж╕рж┐рж╕рзНржЯрзЗржо ржирж┐рж░рзНржнрж░)

### ЁЯзй Problem:

multiset ржХ'ржнрж╛ржмрзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ ржХрждржЯрж┐ ржЙржкрж╛ржжрж╛ржи рж░рж╛ржЦрждрзЗ ржкрж╛рж░ржмрзЗ, рждрж╛ ржмрзЗрж░ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s;

    std::cout << "Max size: " << s.max_size();
}
```

ЁЯУд **Sample Output (ржнрж┐ржирзНржи рж╕рж┐рж╕рзНржЯрзЗржорзЗ ржнрж┐ржирзНржи):**

```
Max size: 461168601842738790
```

---

## тЬЕ Iterator Functions

---

### 4я╕ПтГг `s.begin(), s.end()` тАФ рж╕рж╛ржоржирзЗрж░ ржжрж┐ржХ ржерзЗржХрзЗ ржЗржЯрж╛рж░рзЗржЯ ржХрж░рзЛ

### ЁЯзй Problem:

multiset ржПрж░ рж╕ржм ржЙржкрж╛ржжрж╛ржи рж╕рж╛ржоржирзЗ ржерзЗржХрзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {3, 1, 4};

    for (auto it = s.begin(); it != s.end(); ++it)
        std::cout << *it << " ";
}
```

ЁЯУд **Output:**

```
1 3 4
```

---

### 5я╕ПтГг `s.rbegin(), s.rend()` тАФ ржкрзЗржЫржи ржерзЗржХрзЗ ржЗржЯрж╛рж░рзЗржЯ ржХрж░рзЛ

### ЁЯзй Problem:

multiset ржПрж░ ржЙржкрж╛ржжрж╛ржи рж░рж┐ржнрж╛рж░рзНрж╕ ржЕрж░рзНржбрж╛рж░рзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s = {3, 1, 4};

    for (auto it = s.rbegin(); it != s.rend(); ++it)
        std::cout << *it << " ";
}
```

ЁЯУд **Output:**

```
4 3 1
```

---

### 6я╕ПтГг `cbegin(), cend(), crbegin(), crend()` тАФ const ржЗржЯрж╛рж░рзЗржЯрж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЛ

### ЁЯзй Problem:

multiset ржПрж░ ржЙржкрж╛ржжрж╛ржи const\_iterator ржжрж┐рзЯрзЗ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзЛ (modification allowed ржирзЯ)ред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    const std::multiset<int> s = {2, 5, 1};

    for (auto it = s.cbegin(); it != s.cend(); ++it)
        std::cout << *it << " ";

    std::cout << "\nReverse:\n";
    for (auto it = s.crbegin(); it != s.crend(); ++it)
        std::cout << *it << " ";
}
```

ЁЯУд **Output:**

```
1 2 5  
Reverse:  
5 2 1
```

---

## тЬЕ Others

---

### 7я╕ПтГг `s.swap(other);` тАФ ржжрзБржЗ multiset ржПрж░ ржоржзрзНржпрзЗ data ржЕржжрж▓ржмржжрж▓ ржХрж░рзЛ

### ЁЯзй Problem:

ржжрзБржЗ multiset ржПрж░ ржоржзрзНржпрзЗ ржорж╛ржи ржЕржжрж▓ржмржжрж▓ ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> a = {1, 2};
    std::multiset<int> b = {10, 20, 30};

    a.swap(b);

    std::cout << "a: ";
    for (int x : a) std::cout << x << " ";

    std::cout << "\nb: ";
    for (int x : b) std::cout << x << " ";
}
```

ЁЯУд **Output:**

```
a: 10 20 30  
b: 1 2
```

---

### 8я╕ПтГг `s.get_allocator();` тАФ allocator object рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗ

### ЁЯзй Problem:

ржПржХржЯрж┐ multiset ржПрж░ allocator ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржбрж╛ржпрж╝ржирж╛ржорж┐ржХ ржорзЗржорзЛрж░рж┐ allocate ржХрж░рзЛред

### ЁЯзк Solution:

```cpp
#include <iostream>
#include <set>

int main() {
    std::multiset<int> s;

    auto alloc = s.get_allocator();

    int* p = alloc.allocate(3); // allocate space for 3 integers

    p[0] = 100;
    p[1] = 200;
    p[2] = 300;

    std::cout << p[0] << " " << p[1] << " " << p[2] << "\n";

    alloc.deallocate(p, 3); // free the memory
}
```

ЁЯУд **Output:**

```
100 200 300
```

---



## ЁЯМЯ `std::multiset` Full Reference Sheet тАФ C++ STL


# ЁЯМЯ C++ STL - std::multiset Reference Sheet

## тЬЕ Constructor Functions

| Function                                 | Description                                | Example                                    |
|------------------------------------------|--------------------------------------------|--------------------------------------------|
| `std::multiset<int> s;`                  | Create empty multiset                      | `std::multiset<int> s;`                    |
| `std::multiset<int> s(arr, arr+n);`      | Create from range                          | `std::multiset<int> s(arr, arr+5);`        |
| `std::multiset<int> s(other);`           | Copy constructor                           | `std::multiset<int> copy(s);`              |
| `std::multiset<int> s{1, 2, 3};`         | Initializer list                           | `std::multiset<int> s{1, 2, 3};`           |

---

## тЬЕ Insertion Functions

| Function                                  | Description                                  | Example                              |
|-------------------------------------------|----------------------------------------------|--------------------------------------|
| `insert(value)`                           | Insert an element                            | `s.insert(10);`                      |
| `insert(hint, value)`                     | Insert with iterator hint                    | `s.insert(s.begin(), 10);`           |
| `emplace(value)`                          | In-place insert                              | `s.emplace(10);`                     |

---

## тЬЕ Deletion Functions

| Function                                  | Description                                  | Example                              |
|-------------------------------------------|----------------------------------------------|--------------------------------------|
| `erase(value)`                            | Erase all instances of a value               | `s.erase(2);`                        |
| `erase(pos)`                              | Erase by iterator                            | `s.erase(s.begin());`               |
| `erase(start, end)`                       | Erase range                                  | `s.erase(s.begin(), s.end());`      |
| `clear()`                                 | Erase all elements                           | `s.clear();`                         |

---

## тЬЕ Search & Count

| Function                                  | Description                                  | Example                              |
|-------------------------------------------|----------------------------------------------|--------------------------------------|
| `find(value)`                             | Find first occurrence                        | `auto it = s.find(3);`               |
| `count(value)`                            | Count occurrences of value                   | `s.count(3);`                        |
| `equal_range(value)`                      | Returns pair of iterators                    | `auto p = s.equal_range(3);`         |
| `lower_bound(value)`                      | First element >= value                       | `s.lower_bound(3);`                  |
| `upper_bound(value)`                      | First element > value                        | `s.upper_bound(3);`                  |

---

## тЬЕ Capacity Functions

| Function                                  | Description                                  | Example                              |
|-------------------------------------------|----------------------------------------------|--------------------------------------|
| `empty()`                                 | Check if multiset is empty                   | `s.empty();`                         |
| `size()`                                  | Number of elements                           | `s.size();`                          |
| `max_size()`                              | Maximum number of elements storable          | `s.max_size();`                      |

---

## тЬЕ Iterator Functions

| Function                                  | Description                                  | Example                              |
|-------------------------------------------|----------------------------------------------|--------------------------------------|
| `begin(), end()`                          | Forward iteration                            | `for (auto it = s.begin(); ...)`     |
| `rbegin(), rend()`                        | Reverse iteration                            | `for (auto it = s.rbegin(); ...)`    |
| `cbegin(), cend()`                        | Constant forward iteration                   | `for (auto it = s.cbegin(); ...)`    |
| `crbegin(), crend()`                      | Constant reverse iteration                   | `for (auto it = s.crbegin(); ...)`   |

---

## тЬЕ Other Utilities

| Function                                  | Description                                  | Example                              |
|-------------------------------------------|----------------------------------------------|--------------------------------------|
| `swap(other)`                             | Swap two multisets                           | `a.swap(b);`                         |
| `get_allocator()`                         | Get memory allocator                         | `auto alloc = s.get_allocator();`    |
```

---


